{"ast":null,"code":"import * as Yup from 'yup';\nimport moment from 'moment';\nimport { validationTranslations } from '../../../../../utils/validation_translations';\nimport { workTranslations } from './validator_translations';\nexport const WorkValidator = formatMessage => Yup.object().shape({\n  work: Yup.array().required(formatMessage(workTranslations.atLeastOne)).min(1, formatMessage(workTranslations.atLeastOne)).of(Yup.object().transform(value => ({ ...value,\n    stillEmployed: !value.endDate\n  })).shape({\n    position: Yup.string().required(formatMessage(validationTranslations.required)),\n    name: Yup.string().min(5, formatMessage(validationTranslations.min, {\n      min: 5\n    })),\n    summary: Yup.string().required(formatMessage(validationTranslations.required)).min(30, formatMessage(validationTranslations.min, {\n      min: 30\n    })),\n    place: Yup.object().nullable().shape({\n      name: Yup.string().required(formatMessage(validationTranslations.required)).min(5, formatMessage(validationTranslations.min, {\n        min: 5\n      }))\n    }),\n    startDate: Yup.object().required(formatMessage(validationTranslations.required)).test('is-not-in-future', formatMessage(workTranslations.noFutureDate), value => value && value.isBefore(moment().add(1, 'day'))).test('is-not-empty', formatMessage(validationTranslations.required), value => !!value && !Number.isNaN(Number(value.year())) && !Number.isNaN(Number(value.month()))),\n    endDate: Yup.object().when('stillEmployed', {\n      is: true,\n      then: Yup.object().nullable().notRequired(),\n      otherwise: Yup.object().when('startDate', start => Yup.object().test('is-not-empty', formatMessage(validationTranslations.required), value => !!value && !Number.isNaN(Number(value.year())) && !Number.isNaN(Number(value.month()))).test('isafter', formatMessage(validationTranslations.isAfter), value => {\n        if (!start || Number.isNaN(Number(start.year())) || Number.isNaN(Number(start.month()))) {\n          return true;\n        }\n\n        return moment(value).isAfter(start);\n      }))\n    })\n  }))\n});\nexport const validateWorkComplete = data => {\n  try {\n    Yup.object({\n      work: Yup.array().required().min(1)\n    }).validateSync(data);\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n};","map":{"version":3,"sources":["/root/Desktop/Good-fordev/site-perso/src/package/components/cards/cards_types/experiences/data/validator.js"],"names":["Yup","moment","validationTranslations","workTranslations","WorkValidator","formatMessage","object","shape","work","array","required","atLeastOne","min","of","transform","value","stillEmployed","endDate","position","string","name","summary","place","nullable","startDate","test","noFutureDate","isBefore","add","Number","isNaN","year","month","when","is","then","notRequired","otherwise","start","isAfter","validateWorkComplete","data","validateSync","e"],"mappings":"AAAA,OAAO,KAAKA,GAAZ,MAAqB,KAArB;AACA,OAAOC,MAAP,MAAmB,QAAnB;AACA,SAASC,sBAAT,QAAuC,8CAAvC;AACA,SAASC,gBAAT,QAAiC,0BAAjC;AAEA,OAAO,MAAMC,aAAa,GAAGC,aAAa,IACtCL,GAAG,CAACM,MAAJ,GAAaC,KAAb,CAAmB;AACfC,EAAAA,IAAI,EAAER,GAAG,CAACS,KAAJ,GACDC,QADC,CACQL,aAAa,CAACF,gBAAgB,CAACQ,UAAlB,CADrB,EAEDC,GAFC,CAEG,CAFH,EAEMP,aAAa,CAACF,gBAAgB,CAACQ,UAAlB,CAFnB,EAGDE,EAHC,CAIEb,GAAG,CAACM,MAAJ,GACKQ,SADL,CACeC,KAAK,KAAK,EAAE,GAAGA,KAAL;AAAYC,IAAAA,aAAa,EAAE,CAACD,KAAK,CAACE;AAAlC,GAAL,CADpB,EAEKV,KAFL,CAEW;AACHW,IAAAA,QAAQ,EAAElB,GAAG,CAACmB,MAAJ,GAAaT,QAAb,CAAsBL,aAAa,CAACH,sBAAsB,CAACQ,QAAxB,CAAnC,CADP;AAEHU,IAAAA,IAAI,EAAEpB,GAAG,CAACmB,MAAJ,GAAaP,GAAb,CAAiB,CAAjB,EAAoBP,aAAa,CAACH,sBAAsB,CAACU,GAAxB,EAA6B;AAAEA,MAAAA,GAAG,EAAE;AAAP,KAA7B,CAAjC,CAFH;AAGHS,IAAAA,OAAO,EAAErB,GAAG,CAACmB,MAAJ,GACJT,QADI,CACKL,aAAa,CAACH,sBAAsB,CAACQ,QAAxB,CADlB,EAEJE,GAFI,CAEA,EAFA,EAEIP,aAAa,CAACH,sBAAsB,CAACU,GAAxB,EAA6B;AAAEA,MAAAA,GAAG,EAAE;AAAP,KAA7B,CAFjB,CAHN;AAMHU,IAAAA,KAAK,EAAEtB,GAAG,CAACM,MAAJ,GACFiB,QADE,GAEFhB,KAFE,CAEI;AACHa,MAAAA,IAAI,EAAEpB,GAAG,CAACmB,MAAJ,GACDT,QADC,CACQL,aAAa,CAACH,sBAAsB,CAACQ,QAAxB,CADrB,EAEDE,GAFC,CAEG,CAFH,EAEMP,aAAa,CAACH,sBAAsB,CAACU,GAAxB,EAA6B;AAAEA,QAAAA,GAAG,EAAE;AAAP,OAA7B,CAFnB;AADH,KAFJ,CANJ;AAaHY,IAAAA,SAAS,EAAExB,GAAG,CAACM,MAAJ,GACNI,QADM,CACGL,aAAa,CAACH,sBAAsB,CAACQ,QAAxB,CADhB,EAENe,IAFM,CAGH,kBAHG,EAIHpB,aAAa,CAACF,gBAAgB,CAACuB,YAAlB,CAJV,EAKHX,KAAK,IAAIA,KAAK,IAAIA,KAAK,CAACY,QAAN,CAAe1B,MAAM,GAAG2B,GAAT,CAAa,CAAb,EAAgB,KAAhB,CAAf,CALf,EAONH,IAPM,CAQH,cARG,EASHpB,aAAa,CAACH,sBAAsB,CAACQ,QAAxB,CATV,EAUHK,KAAK,IACD,CAAC,CAACA,KAAF,IACA,CAACc,MAAM,CAACC,KAAP,CAAaD,MAAM,CAACd,KAAK,CAACgB,IAAN,EAAD,CAAnB,CADD,IAEA,CAACF,MAAM,CAACC,KAAP,CAAaD,MAAM,CAACd,KAAK,CAACiB,KAAN,EAAD,CAAnB,CAbF,CAbR;AA6BHf,IAAAA,OAAO,EAAEjB,GAAG,CAACM,MAAJ,GAAa2B,IAAb,CAAkB,eAAlB,EAAmC;AACxCC,MAAAA,EAAE,EAAE,IADoC;AAExCC,MAAAA,IAAI,EAAEnC,GAAG,CAACM,MAAJ,GACDiB,QADC,GAEDa,WAFC,EAFkC;AAKxCC,MAAAA,SAAS,EAAErC,GAAG,CAACM,MAAJ,GAAa2B,IAAb,CAAkB,WAAlB,EAA+BK,KAAK,IAC3CtC,GAAG,CAACM,MAAJ,GACKmB,IADL,CAEQ,cAFR,EAGQpB,aAAa,CAACH,sBAAsB,CAACQ,QAAxB,CAHrB,EAIQK,KAAK,IACD,CAAC,CAACA,KAAF,IACA,CAACc,MAAM,CAACC,KAAP,CAAaD,MAAM,CAACd,KAAK,CAACgB,IAAN,EAAD,CAAnB,CADD,IAEA,CAACF,MAAM,CAACC,KAAP,CAAaD,MAAM,CAACd,KAAK,CAACiB,KAAN,EAAD,CAAnB,CAPb,EASKP,IATL,CASU,SATV,EASqBpB,aAAa,CAACH,sBAAsB,CAACqC,OAAxB,CATlC,EASoExB,KAAK,IAAI;AACrE,YACI,CAACuB,KAAD,IACAT,MAAM,CAACC,KAAP,CAAaD,MAAM,CAACS,KAAK,CAACP,IAAN,EAAD,CAAnB,CADA,IAEAF,MAAM,CAACC,KAAP,CAAaD,MAAM,CAACS,KAAK,CAACN,KAAN,EAAD,CAAnB,CAHJ,EAIE;AACE,iBAAO,IAAP;AACH;;AACD,eAAO/B,MAAM,CAACc,KAAD,CAAN,CAAcwB,OAAd,CAAsBD,KAAtB,CAAP;AACH,OAlBL,CADO;AAL6B,KAAnC;AA7BN,GAFX,CAJF;AADS,CAAnB,CADG;AAmEP,OAAO,MAAME,oBAAoB,GAAGC,IAAI,IAAI;AACxC,MAAI;AACAzC,IAAAA,GAAG,CAACM,MAAJ,CAAW;AACPE,MAAAA,IAAI,EAAER,GAAG,CAACS,KAAJ,GACDC,QADC,GAEDE,GAFC,CAEG,CAFH;AADC,KAAX,EAIG8B,YAJH,CAIgBD,IAJhB;AAKH,GAND,CAME,OAAOE,CAAP,EAAU;AACR,WAAO,KAAP;AACH;;AACD,SAAO,IAAP;AACH,CAXM","sourcesContent":["import * as Yup from 'yup';\nimport moment from 'moment';\nimport { validationTranslations } from '../../../../../utils/validation_translations';\nimport { workTranslations } from './validator_translations';\n\nexport const WorkValidator = formatMessage =>\n    Yup.object().shape({\n        work: Yup.array()\n            .required(formatMessage(workTranslations.atLeastOne))\n            .min(1, formatMessage(workTranslations.atLeastOne))\n            .of(\n                Yup.object()\n                    .transform(value => ({ ...value, stillEmployed: !value.endDate }))\n                    .shape({\n                        position: Yup.string().required(formatMessage(validationTranslations.required)),\n                        name: Yup.string().min(5, formatMessage(validationTranslations.min, { min: 5 })),\n                        summary: Yup.string()\n                            .required(formatMessage(validationTranslations.required))\n                            .min(30, formatMessage(validationTranslations.min, { min: 30 })),\n                        place: Yup.object()\n                            .nullable()\n                            .shape({\n                                name: Yup.string()\n                                    .required(formatMessage(validationTranslations.required))\n                                    .min(5, formatMessage(validationTranslations.min, { min: 5 }))\n                            }),\n                        startDate: Yup.object()\n                            .required(formatMessage(validationTranslations.required))\n                            .test(\n                                'is-not-in-future',\n                                formatMessage(workTranslations.noFutureDate),\n                                value => value && value.isBefore(moment().add(1, 'day'))\n                            )\n                            .test(\n                                'is-not-empty',\n                                formatMessage(validationTranslations.required),\n                                value =>\n                                    !!value &&\n                                    !Number.isNaN(Number(value.year())) &&\n                                    !Number.isNaN(Number(value.month()))\n                            ),\n\n                        endDate: Yup.object().when('stillEmployed', {\n                            is: true,\n                            then: Yup.object()\n                                .nullable()\n                                .notRequired(),\n                            otherwise: Yup.object().when('startDate', start =>\n                                Yup.object()\n                                    .test(\n                                        'is-not-empty',\n                                        formatMessage(validationTranslations.required),\n                                        value =>\n                                            !!value &&\n                                            !Number.isNaN(Number(value.year())) &&\n                                            !Number.isNaN(Number(value.month()))\n                                    )\n                                    .test('isafter', formatMessage(validationTranslations.isAfter), value => {\n                                        if (\n                                            !start ||\n                                            Number.isNaN(Number(start.year())) ||\n                                            Number.isNaN(Number(start.month()))\n                                        ) {\n                                            return true;\n                                        }\n                                        return moment(value).isAfter(start);\n                                    }))\n                        })\n                    })\n            )\n    });\n\nexport const validateWorkComplete = data => {\n    try {\n        Yup.object({\n            work: Yup.array()\n                .required()\n                .min(1)\n        }).validateSync(data);\n    } catch (e) {\n        return false;\n    }\n    return true;\n};\n"]},"metadata":{},"sourceType":"module"}
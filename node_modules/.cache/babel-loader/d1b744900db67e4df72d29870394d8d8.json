{"ast":null,"code":"import { useCallback, useEffect, useRef, useState } from 'react';\nconst DEFAULT_OPTIONS = Object.freeze({\n  type: ['(cities)']\n});\nexport const useGoogleMapsPredictions = (input, options = DEFAULT_OPTIONS) => {\n  const timer = useRef();\n  const autoCompleteService = useRef(null);\n  const [predictions, setPredictions] = useState([]);\n  const handlePlacesPredictionsUpdate = useCallback((receivedPredictions, status) => {\n    // eslint-disable-next-line no-undef\n    if (status !== google.maps.places.PlacesServiceStatus.OK) {\n      setPredictions([]);\n      return;\n    }\n\n    const filteredPredictions = receivedPredictions.filter(p => p.types && !p.types.includes('country'));\n    setPredictions(filteredPredictions);\n  }, []);\n  useEffect(() => {\n    if (typeof google !== 'undefined') {\n      try {\n        // eslint-disable-next-line no-undef\n        autoCompleteService.current = new google.maps.places.AutocompleteService();\n      } catch (e) {\n        console.error('Failed to init google maps autocomplete service', e);\n      }\n    }\n  }, []);\n  useEffect(() => {\n    if (!autoCompleteService.current) {\n      return;\n    }\n\n    if (!input) {\n      setPredictions([]);\n      return;\n    }\n\n    if (timer.current) {\n      clearTimeout(timer.current);\n    }\n\n    timer.current = setTimeout(autoCompleteService.current.getPlacePredictions({\n      input,\n      ...options\n    }, handlePlacesPredictionsUpdate), 200);\n  }, [input, autoCompleteService.current]);\n  return {\n    predictions\n  };\n};","map":{"version":3,"sources":["/root/Desktop/Good-fordev/site-perso/src/package/components/hooks/location/use_google_maps_predictions.js"],"names":["useCallback","useEffect","useRef","useState","DEFAULT_OPTIONS","Object","freeze","type","useGoogleMapsPredictions","input","options","timer","autoCompleteService","predictions","setPredictions","handlePlacesPredictionsUpdate","receivedPredictions","status","google","maps","places","PlacesServiceStatus","OK","filteredPredictions","filter","p","types","includes","current","AutocompleteService","e","console","error","clearTimeout","setTimeout","getPlacePredictions"],"mappings":"AAAA,SAASA,WAAT,EAAsBC,SAAtB,EAAiCC,MAAjC,EAAyCC,QAAzC,QAAyD,OAAzD;AAEA,MAAMC,eAAe,GAAGC,MAAM,CAACC,MAAP,CAAc;AAClCC,EAAAA,IAAI,EAAE,CAAC,UAAD;AAD4B,CAAd,CAAxB;AAIA,OAAO,MAAMC,wBAAwB,GAAG,CAACC,KAAD,EAAQC,OAAO,GAAGN,eAAlB,KAAsC;AAC1E,QAAMO,KAAK,GAAGT,MAAM,EAApB;AACA,QAAMU,mBAAmB,GAAGV,MAAM,CAAC,IAAD,CAAlC;AACA,QAAM,CAACW,WAAD,EAAcC,cAAd,IAAgCX,QAAQ,CAAC,EAAD,CAA9C;AACA,QAAMY,6BAA6B,GAAGf,WAAW,CAAC,CAACgB,mBAAD,EAAsBC,MAAtB,KAAiC;AAC/E;AACA,QAAIA,MAAM,KAAKC,MAAM,CAACC,IAAP,CAAYC,MAAZ,CAAmBC,mBAAnB,CAAuCC,EAAtD,EAA0D;AACtDR,MAAAA,cAAc,CAAC,EAAD,CAAd;AACA;AACH;;AACD,UAAMS,mBAAmB,GAAGP,mBAAmB,CAACQ,MAApB,CAA2BC,CAAC,IAAIA,CAAC,CAACC,KAAF,IAAW,CAACD,CAAC,CAACC,KAAF,CAAQC,QAAR,CAAiB,SAAjB,CAA5C,CAA5B;AACAb,IAAAA,cAAc,CAACS,mBAAD,CAAd;AACH,GARgD,EAQ9C,EAR8C,CAAjD;AASAtB,EAAAA,SAAS,CAAC,MAAM;AACZ,QAAI,OAAOiB,MAAP,KAAkB,WAAtB,EAAmC;AAC/B,UAAI;AACA;AACAN,QAAAA,mBAAmB,CAACgB,OAApB,GAA8B,IAAIV,MAAM,CAACC,IAAP,CAAYC,MAAZ,CAAmBS,mBAAvB,EAA9B;AACH,OAHD,CAGE,OAAOC,CAAP,EAAU;AACRC,QAAAA,OAAO,CAACC,KAAR,CAAc,iDAAd,EAAiEF,CAAjE;AACH;AACJ;AACJ,GATQ,EASN,EATM,CAAT;AAUA7B,EAAAA,SAAS,CAAC,MAAM;AACZ,QAAI,CAACW,mBAAmB,CAACgB,OAAzB,EAAkC;AAC9B;AACH;;AACD,QAAI,CAACnB,KAAL,EAAY;AACRK,MAAAA,cAAc,CAAC,EAAD,CAAd;AACA;AACH;;AACD,QAAIH,KAAK,CAACiB,OAAV,EAAmB;AACfK,MAAAA,YAAY,CAACtB,KAAK,CAACiB,OAAP,CAAZ;AACH;;AACDjB,IAAAA,KAAK,CAACiB,OAAN,GAAgBM,UAAU,CACtBtB,mBAAmB,CAACgB,OAApB,CAA4BO,mBAA5B,CACI;AACI1B,MAAAA,KADJ;AAEI,SAAGC;AAFP,KADJ,EAKIK,6BALJ,CADsB,EAQtB,GARsB,CAA1B;AAUH,GArBQ,EAqBN,CAACN,KAAD,EAAQG,mBAAmB,CAACgB,OAA5B,CArBM,CAAT;AAsBA,SAAO;AAAEf,IAAAA;AAAF,GAAP;AACH,CA9CM","sourcesContent":["import { useCallback, useEffect, useRef, useState } from 'react';\n\nconst DEFAULT_OPTIONS = Object.freeze({\n    type: ['(cities)']\n});\n\nexport const useGoogleMapsPredictions = (input, options = DEFAULT_OPTIONS) => {\n    const timer = useRef();\n    const autoCompleteService = useRef(null);\n    const [predictions, setPredictions] = useState([]);\n    const handlePlacesPredictionsUpdate = useCallback((receivedPredictions, status) => {\n        // eslint-disable-next-line no-undef\n        if (status !== google.maps.places.PlacesServiceStatus.OK) {\n            setPredictions([]);\n            return;\n        }\n        const filteredPredictions = receivedPredictions.filter(p => p.types && !p.types.includes('country'));\n        setPredictions(filteredPredictions);\n    }, []);\n    useEffect(() => {\n        if (typeof google !== 'undefined') {\n            try {\n                // eslint-disable-next-line no-undef\n                autoCompleteService.current = new google.maps.places.AutocompleteService();\n            } catch (e) {\n                console.error('Failed to init google maps autocomplete service', e);\n            }\n        }\n    }, []);\n    useEffect(() => {\n        if (!autoCompleteService.current) {\n            return;\n        }\n        if (!input) {\n            setPredictions([]);\n            return;\n        }\n        if (timer.current) {\n            clearTimeout(timer.current);\n        }\n        timer.current = setTimeout(\n            autoCompleteService.current.getPlacePredictions(\n                {\n                    input,\n                    ...options\n                },\n                handlePlacesPredictionsUpdate\n            ),\n            200\n        );\n    }, [input, autoCompleteService.current]);\n    return { predictions };\n};\n"]},"metadata":{},"sourceType":"module"}